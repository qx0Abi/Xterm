local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Xterm 0.0.1",
   Icon = 0,
   LoadingTitle = "Xterm",
   LoadingSubtitle = "by qx0_",
   ShowText = "Xterm",
   Theme = "Default",
   ToggleUIKeybind = "K",
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil,
      FileName = "Xterm"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided",
      FileName = "Key",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = {"Hello"}
   }
})

local MainTab = Window:CreateTab("🏡Home", nil)
local MainSection = MainTab:CreateSection("Main")

Rayfield:Notify({
   Title = "Xterm 0.0.1",
   Content = "is Loading",
   Duration = 2,
   Image = nil,
})

local InfiniteJumpEnabled = false
local Button = MainTab:CreateButton({
   Name = "InfiniteJump",
   Callback = function()
       local UserInputService = game:GetService("UserInputService")
       local Players = game:GetService("Players")
       local LocalPlayer = Players.LocalPlayer

       InfiniteJumpEnabled = not InfiniteJumpEnabled

       if InfiniteJumpEnabled then
           if not _G.__XTERM_InfiniteJump_Conn then
               _G.__XTERM_InfiniteJump_Conn = UserInputService.JumpRequest:Connect(function()
                   if InfiniteJumpEnabled and LocalPlayer.Character then
                       local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                       if humanoid then
                           humanoid:ChangeState("Jumping")
                       end
                   end
               end)
           end
       else
           if _G.__XTERM_InfiniteJump_Conn and _G.__XTERM_InfiniteJump_Conn.Disconnect then
               _G.__XTERM_InfiniteJump_Conn:Disconnect()
               _G.__XTERM_InfiniteJump_Conn = nil
           end
       end
   end,
})

local noClipEnabled = false
local noClipLoopThread = nil
local characterAddedConn = nil

local function setCharacterCollisions(character, collide)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = collide
        end
    end
end

local function startNoClip()
    noClipEnabled = true
    local player = game.Players.LocalPlayer
    if player and player.Character then
        setCharacterCollisions(player.Character, false)
    end
    if not characterAddedConn then
        characterAddedConn = player.CharacterAdded:Connect(function(char)
            task.wait(0.1)
            if noClipEnabled then
                setCharacterCollisions(char, false)
            end
        end)
    end
    if not noClipLoopThread then
        noClipLoopThread = task.spawn(function()
            while noClipEnabled do
                local pl = game.Players.LocalPlayer
                local char = pl and pl.Character
                if char then
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
                task.wait(0.1)
            end
        end)
    end
end

local function stopNoClip()
    noClipEnabled = false
    if characterAddedConn then
        characterAddedConn:Disconnect()
        characterAddedConn = nil
    end
    local player = game.Players.LocalPlayer
    if player and player.Character then
        setCharacterCollisions(player.Character, true)
    end
end

local NoClipButton = MainTab:CreateButton({
   Name = "Toggle No Clip",
   Callback = function()
       if not noClipEnabled then
           startNoClip()
       else
           stopNoClip()
       end
   end,
})

local speedLoopEnabled = false
local jumpLoopEnabled = false
local speedLoopThread = nil
local jumpLoopThread = nil

local function getCurrentHumanoid()
    local pl = game.Players.LocalPlayer
    return pl and pl.Character and pl.Character:FindFirstChildOfClass("Humanoid") or nil
end

local currentHumanoid = getCurrentHumanoid()
local defaultWalkSpeed = currentHumanoid and currentHumanoid.WalkSpeed or 16
local defaultJumpPower = currentHumanoid and currentHumanoid.JumpPower or 50

local desiredWalkSpeed = defaultWalkSpeed
local desiredJumpPower = defaultJumpPower

local function startSpeedLoop()
    if speedLoopEnabled then return end
    speedLoopEnabled = true
    speedLoopThread = task.spawn(function()
        while speedLoopEnabled do
            local hm = getCurrentHumanoid()
            if hm and desiredWalkSpeed then
                hm.WalkSpeed = desiredWalkSpeed
            end
            task.wait(0.1)
        end
    end)
end

local function stopSpeedLoop()
    speedLoopEnabled = false
    speedLoopThread = nil
end

local function startJumpLoop()
    if jumpLoopEnabled then return end
    jumpLoopEnabled = true
    jumpLoopThread = task.spawn(function()
        while jumpLoopEnabled do
            local hm = getCurrentHumanoid()
            if hm and desiredJumpPower then
                hm.JumpPower = desiredJumpPower
            end
            task.wait(0.1)
        end
    end)
end

local function stopJumpLoop()
    jumpLoopEnabled = false
    jumpLoopThread = nil
end

local InputSpeed = MainTab:CreateInput({
   Name = "Speed",
   CurrentValue = tostring(defaultWalkSpeed),
   PlaceholderText = "Enter Number",
   RemoveTextAfterFocusLost = false,
   Flag = "InputSpeed",
   Callback = function(Text)
       local speedValue = tonumber(Text)
       if speedValue then
           desiredWalkSpeed = speedValue
           if not speedLoopEnabled then
               startSpeedLoop()
           end
       end
   end,
})

local InputJump = MainTab:CreateInput({
   Name = "Jump Height",
   CurrentValue = tostring(defaultJumpPower),
   PlaceholderText = "Enter Number",
   RemoveTextAfterFocusLost = false,
   Flag = "InputJump",
   Callback = function(Text)
       local jumpValue = tonumber(Text)
       if jumpValue then
           desiredJumpPower = jumpValue
           if not jumpLoopEnabled then
               startJumpLoop()
           end
       end
   end,
})

local ResetButton = MainTab:CreateButton({
    Name = "Reset Speed/Jump",
    Callback = function()
        stopSpeedLoop()
        stopJumpLoop()
        desiredWalkSpeed = defaultWalkSpeed
        desiredJumpPower = defaultJumpPower
        local hm = getCurrentHumanoid()
        if hm then
            hm.WalkSpeed = defaultWalkSpeed
            hm.JumpPower = defaultJumpPower
        end
        pcall(function()
            InputSpeed:SetValue(tostring(defaultWalkSpeed))
            InputJump:SetValue(tostring(defaultJumpPower))
        end)
    end,
})

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local SPIN_MULTIPLIER = 40
local IMPULSE_INTERVAL = 0.1
local IMPULSE_STRENGTH = 1200
local ANGVEL_STRENGTH = 1000

local inputValue = 0
local spinSpeed = 0
local glitchedFlying = false
local spinConn = nil
local impulseTask = nil
local currentHRP = nil

local function getHRP(char)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
end

local function clearPhysicsExtras(hrp)
    if not hrp then return end
    for _, c in ipairs(hrp:GetChildren()) do
        if c.Name == "__SPIN_ANGVEL__" or c.Name == "__SPIN_BODYVELOCITY__" then
            c:Destroy()
        end
    end
end

local function applyPhysicsImpulse(hrp)
    if not hrp or not hrp.Parent then return end

    if IMPULSE_STRENGTH and IMPULSE_STRENGTH > 0 then
        local bv = Instance.new("BodyVelocity")
        bv.Name = "__SPIN_BODYVELOCITY__"
        bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
        local forward = hrp.CFrame.LookVector
        bv.Velocity = forward * IMPULSE_STRENGTH + Vector3.new(0, IMPULSE_STRENGTH * 0.18, 0)
        bv.P = 1250
        bv.Parent = hrp
        delay(0.12, function()
            if bv and bv.Parent then pcall(function() bv:Destroy() end) end
        end)
    end

    if ANGVEL_STRENGTH and ANGVEL_STRENGTH > 0 then
        local ang = Instance.new("AngularVelocity")
        ang.Name = "__SPIN_ANGVEL__"
        ang.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
        local axis = Vector3.new(0,1,0) + Vector3.new((math.random()-0.5)*0.22, 0, (math.random()-0.5)*0.22)
        ang.AngularVelocity = axis.Unit * (ANGVEL_STRENGTH * ((spinSpeed/1000) + 0.6))
        ang.Parent = hrp
        delay(0.18, function()
            if ang and ang.Parent then pcall(function() ang:Destroy() end) end
        end)
    end
end

local function startCFrameSpin(hrp)
    if spinConn then return end
    spinConn = RunService.Stepped:Connect(function(_, dt)
        if not glitchedFlying or not hrp or not hrp.Parent then return end
        local degPerSec = (spinSpeed or 0) * SPIN_MULTIPLIER
        if degPerSec <= 0 then return end
        local rotateDeg = degPerSec * dt
        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(rotateDeg), 0)
    end)
end

local function stopGlitchedFly()
    glitchedFlying = false
    if spinConn then
        spinConn:Disconnect()
        spinConn = nil
    end
    if impulseTask then
        pcall(task.cancel, impulseTask)
        impulseTask = nil
    end
    if currentHRP then
        clearPhysicsExtras(currentHRP)
        currentHRP = nil
    end
end

local function startGlitchedFlyForCharacter(char)
    if not char then return end
    stopGlitchedFly()
    currentHRP = getHRP(char)
    if not currentHRP then
        currentHRP = char:WaitForChild("HumanoidRootPart", 2) or getHRP(char)
    end
    if not currentHRP then return end

    glitchedFlying = true
    startCFrameSpin(currentHRP)

    if IMPULSE_INTERVAL and IMPULSE_INTERVAL > 0 then
        impulseTask = task.spawn(function()
            while glitchedFlying do
                if currentHRP and currentHRP.Parent then
                    pcall(function()
                        applyPhysicsImpulse(currentHRP)
                    end)
                end
                task.wait(IMPULSE_INTERVAL)
            end
        end)
    end
end

local SpinInput = MainTab:CreateInput({
   Name = "Auto Farm(Break Your bones)",
   CurrentValue = "0",
   PlaceholderText = "Enter Number",
   RemoveTextAfterFocusLost = false,
   Flag = "SpinInput",
   Callback = function(Text)
       local val = tonumber(Text) or 0
       inputValue = val
       spinSpeed = inputValue -- kein *10 mehr; direktes Mapping
       if spinSpeed ~= 0 then
           local pl = LocalPlayer
           local char = pl and (pl.Character or pl.CharacterAdded and pl.CharacterAdded:Wait())
           if char then
               startGlitchedFlyForCharacter(char)
           end
       else
           stopGlitchedFly()
       end
   end,
})

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.08)
    if currentHRP then
        clearPhysicsExtras(currentHRP)
    end
    currentHRP = nil
    if spinSpeed and spinSpeed ~= 0 then
        -- Warte 5 Sekunden nach Respawn bevor Glitched Fly gestartet wird
        task.spawn(function()
            task.wait(5)
            -- Stelle sicher, dass der Charakter noch derselbe ist und spinSpeed noch aktiv ist
            if LocalPlayer.Character == char and spinSpeed and spinSpeed ~= 0 then
                startGlitchedFlyForCharacter(char)
            end
        end)
    end
end)

if game.BindToClose then
    game:BindToClose(function()
        stopGlitchedFly()
    end)
end

local TeleportTab = Window:CreateTab("🧬Teleports", nil)
local TeleportSection = TeleportTab:CreateSection("Teleport")

local function GetOnlinePlayers()
    local onlinePlayers = {}
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            table.insert(onlinePlayers, player.Name)
        end
    end
    return onlinePlayers
end

local function TeleportToPlayer(playerName)
    local player = game.Players:FindFirstChild(playerName)
    if player and player.Character and player.Character.PrimaryPart then
        local character = game.Players.LocalPlayer.Character
        if character and character.PrimaryPart then
            character:SetPrimaryPartCFrame(player.Character.PrimaryPart.CFrame)
        end
    end
end

local Dropdown = TeleportTab:CreateDropdown({
    Name = "Online Spieler",
    Options = GetOnlinePlayers(),
    CurrentOption = {GetOnlinePlayers()[1]},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(Options)
        TeleportToPlayer(Options[1])
    end,
})

game.Players.PlayerAdded:Connect(function()
    Dropdown:UpdateOptions(GetOnlinePlayers())
end)

game.Players.PlayerRemoving:Connect(function()
    Dropdown:UpdateOptions(GetOnlinePlayers())
end)

local ButtonX = TeleportTab:CreateButton({
   Name = "X",
   Callback = function()
       local pl = game.Players.LocalPlayer
       if pl and pl.Character and pl.Character:FindFirstChildOfClass("Humanoid") then
           pl.Character.Humanoid.JumpPower = 50000
       end
   end,
})
