local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "Xterm Break Bones v3.0",
    Icon = "skull",
    Author = "by qx0_",
    Folder = "Xterm_WindUI",
    
    OpenButton = {
        Title = "Xterm 3.0",
        Icon = "bone",
        CornerRadius = UDim.new(0, 16),
        StrokeThickness = 2,
        Color = ColorSequence.new(
            Color3.fromHex("FF0F7B"),
            Color3.fromHex("F89B29")
        ),
        Enabled = true,
        Draggable = true,
        OnlyMobile = false,
    }
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer

-- Variables
local autoBuy = false
local autoBuyTask = nil
local autoBuyRagdoll = false
local autoBuyRagdollTask = nil

local isActive = false
local damageObjects = {}
local damageConnection = nil
local spawnCount = 10

local forceMovement = false
local forceMovementLoop = nil
local autoFarmWasActive = false
local isMovingWithJoystick = false

local STRONG = {
    MIN_SPEED = 180,
    MAX_SPEED = 420,
    BOOST_MIN = 500,
    BOOST_MAX = 900,
    BOOST_CHANCE = 3,
    BODY_MAXFORCE = 1e6,
}

local defaultGravity = workspace.Gravity
local gravityOn = false
local desiredGravity = 100000

local autoClaim = false
local autoAccept = false
local autoMastery = false

-- Performance Variables
local render3DEnabled = true
local originalRenderSettings = {}
local performanceMode = false
local lowQualityMode = false

-- Helper Functions
local function setPartVisibility(part, invisible)
    if not part then return end
    if invisible then
        part.Transparency = 1
        part.CastShadow = false
    else
        part.Transparency = 0
        part.CastShadow = true
    end
end

local function createDamageObjects()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local playerPosition = character.HumanoidRootPart.Position

    for i = 1, spawnCount do
        local part = Instance.new("Part")
        part.Name = "DamageObject_" .. i
        part.Size = Vector3.new(
            math.random(3, 10),
            math.random(3, 10),
            math.random(3, 10)
        )
        part.Material = Enum.Material.Concrete
        part.BrickColor = BrickColor.new("Really black")
        part.CanCollide = true
        part.Anchored = false
        part.CFrame = CFrame.new(playerPosition + Vector3.new(
            math.random(-18, 18),
            math.random(0, 8),
            math.random(-18, 18)
        ))
        part.Parent = workspace

        setPartVisibility(part, true)

        local bodyVel = Instance.new("BodyVelocity")
        bodyVel.MaxForce = Vector3.new(STRONG.BODY_MAXFORCE, STRONG.BODY_MAXFORCE, STRONG.BODY_MAXFORCE)
        bodyVel.Velocity = Vector3.new(0, 0, 0)
        bodyVel.Parent = part

        table.insert(damageObjects, {part = part, bodyVel = bodyVel})
    end
end

local function updateAllPartVisibility(invisible)
    for _, objData in pairs(damageObjects) do
        if objData and objData.part and objData.part.Parent then
            setPartVisibility(objData.part, true)
        end
    end
end

local function moveDamageObjects()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local playerPosition = character.HumanoidRootPart.Position

    for _, objData in pairs(damageObjects) do
        if objData and objData.part and objData.part.Parent and objData.bodyVel then
            local part = objData.part
            local bodyVel = objData.bodyVel

            local time = tick() * 4
            local radius = math.random(6, 20)
            local angle = time + (part.Name:byte() * 0.2)

            local targetPos = playerPosition + Vector3.new(
                math.cos(angle) * radius,
                math.sin(time * 2) * 12,
                math.sin(angle) * radius
            )

            local dir = (targetPos - part.Position)
            if dir.Magnitude > 0.1 then
                local baseSpeed = math.random(STRONG.MIN_SPEED, STRONG.MAX_SPEED)
                bodyVel.Velocity = dir.Unit * baseSpeed
            else
                bodyVel.Velocity = Vector3.new(0, 0, 0)
            end

            if math.random(1, STRONG.BOOST_CHANCE) == 1 then
                local boostDir = (playerPosition - part.Position)
                boostDir = Vector3.new(boostDir.X, 0, boostDir.Z)
                if boostDir.Magnitude == 0 then
                    boostDir = Vector3.new((math.random()-0.5), 0, (math.random()-0.5))
                end
                boostDir = boostDir.Unit
                local boostSpeed = math.random(STRONG.BOOST_MIN, STRONG.BOOST_MAX)
                bodyVel.Velocity = boostDir * boostSpeed

                local origMax = bodyVel.MaxForce
                bodyVel.MaxForce = Vector3.new(STRONG.BODY_MAXFORCE, STRONG.BODY_MAXFORCE, STRONG.BODY_MAXFORCE)
                delay(0.15, function()
                    if bodyVel and bodyVel.Parent then
                        bodyVel.MaxForce = origMax
                    end
                end)
            end

            part.CFrame = part.CFrame * CFrame.Angles(
                math.rad(math.random(-40, 40)),
                math.rad(math.random(-40, 40)),
                math.rad(math.random(-40, 40))
            )
        end
    end
end

local function cleanupDamageObjects()
    for _, objData in pairs(damageObjects) do
        if objData and objData.part and objData.part.Parent then
            objData.part:Destroy()
        end
    end
    damageObjects = {}
end

local function breakBones()
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = math.max(2, humanoid.WalkSpeed * 0.3)
        humanoid.JumpPower = math.max(5, humanoid.JumpPower * 0.2)
    end
end

local function ensureDamageLoop()
    if damageConnection and damageConnection.Connected then return end
    damageConnection = RunService.Heartbeat:Connect(function()
        if isActive then
            moveDamageObjects()
            if math.random(1, 120) == 1 then
                breakBones()
            end
        end
    end)
end

local function setGravity(on)
    local ok, err = pcall(function()
        if on then
            workspace.Gravity = desiredGravity
        else
            workspace.Gravity = defaultGravity or 196.2
        end
    end)
    if not ok then
        warn("Fehler beim Setzen der Gravit√§t: "..tostring(err))
    end
end

local function startForceMovement()
    if forceMovementLoop then return end
    
    forceMovementLoop = RunService.Heartbeat:Connect(function()
        if not forceMovement then return end
        
        local character = LocalPlayer.Character
        if not character then return end
        
        pcall(function()
            local humanoid = character:FindFirstChild("Humanoid")
            local hrp = character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and hrp then
                local moveDir = humanoid.MoveDirection
                
                if moveDir.Magnitude > 0.05 then
                    if not isMovingWithJoystick then
                        isMovingWithJoystick = true
                        if isActive then
                            autoFarmWasActive = true
                            if damageConnection then
                                damageConnection:Disconnect()
                                damageConnection = nil
                            end
                            cleanupDamageObjects()
                        end
                    end
                    
                    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                    humanoid.PlatformStand = false
                    
                    local currentVel = hrp.AssemblyLinearVelocity
                    hrp.AssemblyLinearVelocity = Vector3.new(
                        moveDir.X * 35,
                        currentVel.Y,
                        moveDir.Z * 35
                    )
                else
                    if isMovingWithJoystick then
                        isMovingWithJoystick = false
                        if autoFarmWasActive and isActive then
                            task.spawn(function()
                                task.wait(0.5)
                                if not isMovingWithJoystick and isActive then
                                    createDamageObjects()
                                    ensureDamageLoop()
                                end
                            end)
                            autoFarmWasActive = false
                        end
                    end
                end
            end
        end)
    end)
end

local function stopForceMovement()
    if forceMovementLoop then
        forceMovementLoop:Disconnect()
        forceMovementLoop = nil
    end
    
    local character = LocalPlayer.Character
    if character then
        pcall(function()
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                task.wait(0.1)
                humanoid:ChangeState(Enum.HumanoidStateType.Running)
            end
        end)
    end
end

local function fireRemote(remoteName)
    local success, err = pcall(function()
        local player = game:GetService("Players").LocalPlayer
        local targetPlayer = game:GetService("Players"):FindFirstChild(player.Name) or player
        local args = { targetPlayer }
        local remotes = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
        local remote = remotes:WaitForChild(remoteName)
        remote:FireServer(unpack(args))
    end)
    if not success then
        warn("Fehler beim Aufrufen von " .. remoteName .. ": " .. tostring(err))
    end
end

local function fireMastery()
    local ok, err = pcall(function()
        local player = game:GetService("Players").LocalPlayer
        local remotes = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
        local remote = remotes:WaitForChild("MasteryLevel")
        remote:FireServer(player)
    end)
    if not ok then
        warn("Fehler beim Aufrufen von MasteryLevel: "..tostring(err))
    end
end

-- Performance Functions
local function saveRenderSettings()
    pcall(function()
        local settings = UserSettings():GetService("UserGameSettings")
        originalRenderSettings = {
            SavedQualityLevel = settings.SavedQualityLevel,
            GraphicsQualityLevel = settings.GraphicsQualityLevel,
        }
    end)
end

local function toggle3DRendering(enabled)
    pcall(function()
        render3DEnabled = enabled
        RunService:Set3dRenderingEnabled(enabled)
        
        if not enabled then
            WindUI:Notify({
                Title = "3D Rendering",
                Content = "Deaktiviert - Nur UI sichtbar",
                Icon = "eye-off",
            })
        else
            WindUI:Notify({
                Title = "3D Rendering",
                Content = "Aktiviert",
                Icon = "eye",
            })
        end
    end)
end

local function setLowQuality(enabled)
    pcall(function()
        local settings = UserSettings():GetService("UserGameSettings")
        
        if enabled then
            saveRenderSettings()
            settings.SavedQualityLevel = Enum.SavedQualitySetting.QualityLevel1
            settings.GraphicsQualityLevel = 1
            
            -- Lighting Optimierungen
            Lighting.GlobalShadows = false
            Lighting.FogEnd = 100
            Lighting.Brightness = 2
            
            WindUI:Notify({
                Title = "Low Quality Mode",
                Content = "Aktiviert - Maximale Performance",
                Icon = "zap",
            })
        else
            if originalRenderSettings.SavedQualityLevel then
                settings.SavedQualityLevel = originalRenderSettings.SavedQualityLevel
                settings.GraphicsQualityLevel = originalRenderSettings.GraphicsQualityLevel
            end
            
            Lighting.GlobalShadows = true
            Lighting.FogEnd = 100000
            Lighting.Brightness = 1
            
            WindUI:Notify({
                Title = "Low Quality Mode",
                Content = "Deaktiviert",
                Icon = "check",
            })
        end
    end)
end

local function enablePerformanceMode(enabled)
    pcall(function()
        performanceMode = enabled
        
        if enabled then
            -- Workspace Optimierungen
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
                    obj.Enabled = false
                end
                
                if obj:IsA("BasePart") then
                    obj.Material = Enum.Material.SmoothPlastic
                    obj.CastShadow = false
                    obj.Reflectance = 0
                end
                
                if obj:IsA("Decal") or obj:IsA("Texture") then
                    obj.Transparency = 1
                end
            end
            
            -- Lighting Effekte deaktivieren
            for _, effect in pairs(Lighting:GetChildren()) do
                if effect:IsA("PostEffect") then
                    effect.Enabled = false
                end
            end
            
            WindUI:Notify({
                Title = "Performance Mode",
                Content = "Aktiviert - Alle Effekte deaktiviert",
                Icon = "zap",
            })
        else
            -- Effekte wieder aktivieren
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
                    obj.Enabled = true
                end
                
                if obj:IsA("BasePart") then
                    obj.CastShadow = true
                end
                
                if obj:IsA("Decal") or obj:IsA("Texture") then
                    obj.Transparency = 0
                end
            end
            
            for _, effect in pairs(Lighting:GetChildren()) do
                if effect:IsA("PostEffect") then
                    effect.Enabled = true
                end
            end
            
            WindUI:Notify({
                Title = "Performance Mode",
                Content = "Deaktiviert",
                Icon = "check",
            })
        end
    end)
end

local function reduceDrawDistance(enabled)
    pcall(function()
        if enabled then
            workspace.StreamingMinRadius = 32
            workspace.StreamingTargetRadius = 64
        else
            workspace.StreamingMinRadius = 64
            workspace.StreamingTargetRadius = 1024
        end
    end)
end

local function disableAnimations(enabled)
    pcall(function()
        local character = LocalPlayer.Character
        if not character then return end
        
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid then return end
        
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if animator and enabled then
            for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                track:Stop()
            end
            animator.Parent = nil
        elseif not enabled and not animator then
            animator = Instance.new("Animator")
            animator.Parent = humanoid
        end
    end)
end

-- Notification
WindUI:Notify({
    Title = "Xterm Break Your Bones",
    Content = "Script Loaded!",
    Icon = "check",
})

-- Tabs
local AutoFarmTab = Window:Tab({
    Title = "Auto Farm",
    Icon = "zap",
})

local ShopTab = Window:Tab({
    Title = "Shop",
    Icon = "shopping-cart",
})

local PerformanceTab = Window:Tab({
    Title = "Performance",
    Icon = "gauge",
})

-- Auto Farm Tab
AutoFarmTab:Section({
    Title = "ü¶¥üî® Bone Breaker üî®ü¶¥",
})

AutoFarmTab:Toggle({
    Title = "Auto Farm Smasher",
    Desc = "Now the Main Auto Farm",
    Default = false,
    Callback = function(state)
        isActive = state
        if isActive then
            if #damageObjects == 0 then
                createDamageObjects()
            else
                updateAllPartVisibility(true)
            end
            ensureDamageLoop()
        else
            if damageConnection then
                damageConnection:Disconnect()
                damageConnection = nil
            end
            cleanupDamageObjects()
        end
    end
})

AutoFarmTab:Slider({
    Title = "Strength Auto Farm",
    Desc = "Strength of Smasher",
    Step = 1,
    Value = {
        Min = 1,
        Max = 100,
        Default = spawnCount,
    },
    Callback = function(val)
        local n = tonumber(val) or spawnCount
        spawnCount = math.clamp(math.floor(n), 1, 100)
    end
})

AutoFarmTab:Space()

AutoFarmTab:Toggle({
    Title = "Make yourself Heavy",
    Desc = "Insanely High Gravity",
    Default = false,
    Callback = function(val)
        gravityOn = val
        setGravity(gravityOn)
    end
})

AutoFarmTab:Toggle({
    Title = "Force Movement Control [BETA]",
    Desc = "Perfect to get unstuck from some places works with Autofarm",
    Default = false,
    Callback = function(val)
        forceMovement = val
        if forceMovement then
            startForceMovement()
        else
            stopForceMovement()
        end
    end
})

AutoFarmTab:Space()

AutoFarmTab:Toggle({
    Title = "Auto Claim Quest",
    Default = false,
    Callback = function(v)
        autoClaim = v
    end
})

AutoFarmTab:Toggle({
    Title = "Auto Accept Quest",
    Default = false,
    Callback = function(v)
        autoAccept = v
    end
})

AutoFarmTab:Toggle({
    Title = "Auto Claim Mastery",
    Default = false,
    Callback = function(v)
        autoMastery = v
    end
})

-- Performance Tab
PerformanceTab:Section({
    Title = "üöÄ Graphics & Performance üöÄ",
})

PerformanceTab:Toggle({
    Title = "Disable 3D Rendering",
    Desc = "Show only UI - Max Fps",
    Default = false,
    Callback = function(val)
        toggle3DRendering(not val)
    end
})

PerformanceTab:Toggle({
    Title = "Low Quality Mode",
    Desc = "Reduce game quality",
    Default = false,
    Callback = function(val)
        lowQualityMode = val
        setLowQuality(val)
    end
})

PerformanceTab:Toggle({
    Title = "Performance Mode",
    Desc = "Disables particles, shadows & effects",
    Default = false,
    Callback = function(val)
        enablePerformanceMode(val)
    end
})

PerformanceTab:Toggle({
    Title = "Reduce Draw Distance",
    Desc = "Reduces render distance for better FPS",
    Default = false,
    Callback = function(val)
        reduceDrawDistance(val)
    end
})

-- Shop Tab
ShopTab:Section({
    Title = "üõçÔ∏è Shopping üõçÔ∏è",
})

ShopTab:Toggle({
    Title = "Auto Buy Body Parts",
    Desc = "Automatically purchases body parts",
    Default = false,
    Callback = function(state)
        autoBuy = state
        if autoBuy then
            if autoBuyTask and task.cancel then pcall(task.cancel, autoBuyTask) end
            autoBuyTask = task.spawn(function()
                while autoBuy do
                    for _, part in ipairs({"Head","Torso","Leg","Arm"}) do
                        pcall(function()
                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseBoneUpgrade"):FireServer(part)
                        end)
                    end
                    task.wait(0.5)
                end
            end)
        else
            if autoBuyTask then pcall(task.cancel, autoBuyTask) autoBuyTask = nil end
        end
    end
})

ShopTab:Toggle({
    Title = "Auto Buy Next Ragdoll",
    Desc = "Automatically purchases next ragdoll",
    Default = false,
    Callback = function(state)
        autoBuyRagdoll = state
        if autoBuyRagdoll then
            if autoBuyRagdollTask and task.cancel then pcall(task.cancel, autoBuyRagdollTask) end
            autoBuyRagdollTask = task.spawn(function()
                while autoBuyRagdoll do
                    pcall(function()
                        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseNextRagdoll"):FireServer()
                    end)
                    task.wait(0.5)
                end
            end)
        else
            if autoBuyRagdollTask then pcall(task.cancel, autoBuyRagdollTask) autoBuyRagdollTask = nil end
        end
    end
})

-- Auto Buy Next Pal
local RollPalRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("RollPal")
local autoRunning = false
local autoConn

ShopTab:Toggle({
    Title = "Auto Buy Next Pal",
    Desc = "Automatically purchases next pals",
    Default = false,
    Callback = function(Value)
        if Value and not autoRunning then
            autoRunning = true
            autoConn = task.spawn(function()
                while autoRunning do
                    pcall(function()
                        RollPalRemote:FireServer()
                    end)
                    task.wait(0.5)
                end
            end)
        elseif not Value and autoRunning then
            autoRunning = false
            autoConn = nil
        end
    end
})

ShopTab:Space()

-- Ragdoll Dropdown
local Ragdolls = {}
local function addRagdoll(name)
    if not name or name == "" then return false end
    for _, v in ipairs(Ragdolls) do if v == name then return false end end
    table.insert(Ragdolls, name)
    return true
end

local function detectCurrentRagdoll()
    local a = LocalPlayer:GetAttribute("Ragdoll")
    if a and a ~= "" then return tostring(a) end
    
    if LocalPlayer.Character then
        a = LocalPlayer.Character:GetAttribute("Ragdoll")
        if a and a ~= "" then return tostring(a) end
    end
    
    local folder = ReplicatedStorage:FindFirstChild("Ragdolls") or ReplicatedStorage:FindFirstChild("RagdollModels")
    if folder then
        for _, child in ipairs(folder:GetChildren()) do
            if child.Name and child.Name ~= "" then
                addRagdoll(child.Name)
            end
        end
    end
    
    return nil
end

local defaults = {"Default","Noodle","Mutant"}
for _, d in ipairs(defaults) do addRagdoll(d) end

local detected = detectCurrentRagdoll()
if detected then addRagdoll(detected) end

local selectedRagdoll = detected or Ragdolls[1] or "Default"

ShopTab:Dropdown({
    Title = "Select Ragdoll",
    Desc = "Shows all Ragdolls",
    Values = Ragdolls,
    Value = selectedRagdoll,
    Callback = function(val)
        selectedRagdoll = val
    end
})

ShopTab:Button({
    Title = "Equip Selected Ragdoll",
    Icon = "user",
    Callback = function()
        local toEquip = selectedRagdoll or Ragdolls[1]
        if not toEquip or toEquip == "" then return end
        pcall(function()
            local remotes = ReplicatedStorage:WaitForChild("Remotes", 2)
            if remotes and remotes:FindFirstChild("EquipRagdoll") then
                remotes:WaitForChild("EquipRagdoll"):FireServer(toEquip)
                WindUI:Notify({
                    Title = "Ragdoll Equipped",
                    Content = toEquip,
                    Icon = "check",
                })
            end
        end)
    end
})

ShopTab:Space()

-- Material Dropdown
local Materials = {}
local function addMaterial(name)
    if not name or name == "" then return false end
    for _, v in ipairs(Materials) do if v == name then return false end end
    table.insert(Materials, name)
    return true
end

local materialDefaults = {"Default", "Spark", "Glass"}
for _, d in ipairs(materialDefaults) do addMaterial(d) end

local materialFolder = ReplicatedStorage:FindFirstChild("Materials") or ReplicatedStorage:FindFirstChild("MaterialModifiers") or ReplicatedStorage:FindFirstChild("Modifiers")
if materialFolder then
    for _, c in ipairs(materialFolder:GetChildren()) do
        if c.Name and c.Name ~= "" then addMaterial(c.Name) end
    end
end

local selectedMaterial = Materials[1] or "Default"

ShopTab:Dropdown({
    Title = "Select Material",
    Desc = "Shows all Materials/Modifiers",
    Values = Materials,
    Value = selectedMaterial,
    Callback = function(val)
        selectedMaterial = val
    end
})

ShopTab:Button({
    Title = "Equip Selected Material",
    Icon = "sparkles",
    Callback = function()
        local toEquip = selectedMaterial or Materials[1]
        if not toEquip or toEquip == "" then return end
        pcall(function()
            local remotes = ReplicatedStorage:WaitForChild("Remotes", 2)
            if remotes and remotes:FindFirstChild("SelectModifier") then
                remotes:WaitForChild("SelectModifier"):FireServer(toEquip)
                WindUI:Notify({
                    Title = "Material Equipped",
                    Content = toEquip,
                    Icon = "check",
                })
            end
        end)
    end
})

ShopTab:Space()

-- Shop Buttons
ShopTab:Button({
    Title = "Buy All Body Parts",
    Icon = "package",
    Callback = function()
        for _, part in ipairs({"Head","Torso","Leg","Arm"}) do
            pcall(function()
                ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseBoneUpgrade"):FireServer(part)
            end)
        end
        WindUI:Notify({
            Title = "Purchase",
            Content = "Bought all body parts!",
            Icon = "shopping-bag",
        })
    end
})

ShopTab:Button({
    Title = "Purchase Next Ragdoll",
    Icon = "user-plus",
    Callback = function()
        pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseNextRagdoll"):FireServer()
        end)
    end
})

ShopTab:Button({
    Title = "Refine Ragdoll",
    Icon = "wand-sparkles",
    Callback = function()
        pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("RefineRagdoll"):FireServer()
        end)
    end
})

ShopTab:Button({
    Title = "Buy Next Pal",
    Icon = "heart",
    Callback = function()
        pcall(function()
            RollPalRemote:FireServer()
        end)
    end
})

ShopTab:Space()

ShopTab:Button({
    Title = "Buy Head",
    Callback = function()
        pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseBoneUpgrade"):FireServer("Head")
        end)
    end
})

ShopTab:Button({
    Title = "Buy Torso",
    Callback = function()
        pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseBoneUpgrade"):FireServer("Torso")
        end)
    end
})

ShopTab:Button({
    Title = "Buy Leg",
    Callback = function()
        pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseBoneUpgrade"):FireServer("Leg")
        end)
    end
})

ShopTab:Button({
    Title = "Buy Arm",
    Callback = function()
        pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("PurchaseBoneUpgrade"):FireServer("Arm")
        end)
    end
})

-- Background Tasks
spawn(function()
    while true do
        if autoClaim then
            fireRemote("ClaimQuest")
        end
        wait(3)
    end
end)

spawn(function()
    while true do
        if autoAccept then
            fireRemote("StartQuest")
        end
        wait(3)
    end
end)

spawn(function()
    while true do
        if autoMastery then
            fireMastery()
        end
        wait(3)
    end
end)

-- Character Respawn Handler
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.08)

    local desired = isActive
    if damageConnection then
        damageConnection:Disconnect()
        damageConnection = nil
    end
    cleanupDamageObjects()
    
    -- Restart force movement if it was enabled
    if forceMovement then
        stopForceMovement()
        task.wait(0.5)
        startForceMovement()
    end
    
    if desired then
        task.spawn(function()
            task.wait(10)
            if LocalPlayer.Character == char then
                if #damageObjects == 0 then
                    createDamageObjects()
                else
                    updateAllPartVisibility(true)
                end
                ensureDamageLoop()
            end
        end)
    end
end)

-- Cleanup on Close
if game.BindToClose then
    pcall(function()
        game:BindToClose(function()
            if damageConnection then
                damageConnection:Disconnect()
                damageConnection = nil
            end
            stopForceMovement()
            cleanupDamageObjects()
        end)
    end)
end
